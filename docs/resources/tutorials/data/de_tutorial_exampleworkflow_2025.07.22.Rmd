---
title: 'FAS Informatics July 2025:Differential Expression Tutorial Example'
output:
  html_document: default
---

# I. Preliminaries
The goal of this workshop is to provide an introduction to differential expression analyses using RNA-seq data. While there are now many published methods for tackling specific steps, as well as full-blown pipelines, we will focus on using the outputs of the nf-core/rnaseq workflow that generates expression estimates from STAR alignments with salmon, to conduct differential expression tests with limma voom.

The expression estimates fed into sleuth and limma voom were created with an annotated genome. The process involved in performing such analyses using a de novo transcriptome assembly is quite similar, with the caveat that there can be biases in expression estimates derived from these methods, and the pipeline for filtering, annotating, and clustering such assemblies into gene level annotations has a substantial impact on the robustness of expression estimates.  

A broader goal of this workshop is to demonstrate how to analyze complex designs that are not the standard one treatment, two condition analyses that are prevalent in the literature. 

## Sample data
Our sample data comprises 12 paired-end RNA-seq libraries for whole body samples of *Drosophila melanogaster* from two geographic regions (Panama and Maine), with two temperature treatments ("low" ane "high") for each region, featuring three biological replicates for each region x treatment combination. Previously, these data were used to look for parallel gene expression patterns between high and low latitude populations (Zhao et al, 2015, *PLoS Genetics*)

## Loading required R libraries
First, install the R libraries that will be used for today's analyses:
```{r,quietly = TRUE}
install.packages("tidyverse")

if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("limma","edgeR")
```

Then load them:

```{r, echo=TRUE}
library(limma)
library(edgeR)
library(tidyverse)
```

# II. Analysis with limma voom

### 1. load gene-level abundance table
The first two columns of *salmon.merged.gene_counts.tsv* are "gene_id", the original gene id in the annotation, and "gene_name", the gene symbol. There may be cases in which a gene symbol is not unique among gene ids, such that it is useful to concatenate these two columns into a new label, which we do here. To manipulate the data into a matrix format that limma expects, we also need to remove the id and name information from the data table, and set the new concatenated label as row names. We do basic table manipulation by loading the table as a tibble via tidyverse, but then, since tidyverse doesn't accomodate row names, convert back to a data frame. 
```{r,echo=TRUE}
expression_data <-read_table("salmon.merged.gene_counts.tsv") %>%
                  mutate(gene_id_symbol=paste(gene_id,gene_name,sep="_")) %>%
                  select(!c(gene_id,gene_name)) %>%
                  relocate(gene_id_symbol)

new_ids=expression_data$gene_id_symbol
expression_data <- expression_data %>% select(!c(gene_id_symbol))
expression_data <-as.data.frame(expression_data)
row.names(expression_data)=new_ids
                  
```

### 2. Load sample info
We not only load the sample info, but also create a new variable, *pop_temp*, that is the concatenation of the two categorical variables. We don't use this variable for downstream analyses--although we could if we wanted to specify particular linear contrasts--but for our purposes, we will use this variable when filtering out lowly expressed genes, as the filtering is also meant to insure that there are sufficient within-group counts.

```{r}
sample_info <- read.table("expression_data/dme_elev_samples.tsv",header = TRUE, stringsAsFactors=FALSE)
sample_info$pop_temp<-paste(sample_info$population,sample_info$temp,sep="_")
```

### 3. Create Digital Gene Expression (DGE) object

```{r}
DGE=DGEList(expression_data,samples=sample_info$sample,group=c(sample_info$sample_info$pop_temp))
```

### 4. filtering lowly expressed genes
A number of transcripts/genes will be not expressed at all in any sample, or may only be expressed in a small number of samples. In the latter case, testing for differential expression is noisy and under-powered. 
```{r}
keep.exprs <- filterByExpr(DGE, group=DGE$samples$group)
DGE <- DGE[keep.exprs,, keep.lib.sizes=FALSE]
```

### 5. TMM normalization
The next step is conducting normalization of the counts across samples so that library size differences and the effects of genes that are highly expressed and sample specific are accounted for. Regarding the latter, we want to avoid having a few genes take up expression sequencing "real estate" given the overall number of reads generated by a sample, such that it reduces the reads in other transcripts in a way that would lead to false positive DE. To do this, we use the trimmed mean of M-values (TMM)  of Robinson and Oshlack (2010) available in edgeR. Note, one can use other normalization schemes, and I have seen some evidence that conditional quantile normalizartion (CQN) mignt be worth considering as an alternative.

```{r}
DGE=calcNormFactors(DGE,method =c("TMM"))
```

### 6. Quick and dirty MDS visualization 
We do this to make sure there are no outliers with respect to a particular experimental variable:
```{r,echo=TRUE}
tempvals<-sample_info$temp
plotMDS(DGE,top=500,col=ifelse(tempvals=="low","blue","red"),gene.selection="common")

popvals<-sample_info$population
plotMDS(DGE,top=500,col=ifelse(popvals=="maine","darkgreen","dodgerblue"),gene.selection="common")


```

As expected, there is clear separation between temeprature regimes and geographic locations, but no outliers indicating bad samples or potential label swaps.


## The vanilla one factor, two treatment DE analysis
A fundamental step of DE analysis is to construct a design matrix that will be used to fit the linear model. In our simple vanilla 2-condition, example we can simply use the temp variable in the s2c table to create a matrix. which represents binary 0/1 encodings of the temp conditions.

### 7. Create design matrix:
```{r,echo=TRUE}
design_temp=model.matrix(~temp, data=sample_info)
design_temp
```

### 8a. Running limma
After creating the design matrix object, the standard approach is to next run limma voom on the DGE object, e.g.:
```{r,echo=TRUE,eval=FALSE}
v <- voom(DGE, design=design_temp, plot=TRUE)
```
**However** ... while this works fine under an ideal scenario, it becomes a problem if there is variation in sample quality, or more generally, there is some indication that a subset of samples appear as outliers via MDS, PCA, etc. Particularly for RNA-seq experiments where researchers may only have a few repicates per sample, discarding outlier samples is not feasible because it may lead to few if any biological replicates for some subset of treatments. 

A better solution to this problem is to apply weights to samples such that outlier samples are down-weighted during differential expression calculations. Limma voom does this by calculating "empirical quality weights" for each sample. Note that we don't specify a normalization method becaues the data have already been normalized with TMM.

### 8b. Run limma voom with sample quality weights:
```{r,echo=TRUE}
vwts <- voomWithQualityWeights(DGE, design=design_temp,normalize.method="none", plot=TRUE)
```

**Note:** we have already applied TMM normalization, thus can set the normalization argument to none. This above command will also generate a plot with two panels showing the mean-variance relationship fit on the left, and a barplot of weights assigned to individual samples.

### 9. Then, run the linear model fitting procedure 1st step:
```{r,echo=TRUE}
fit=lmFit(vwts,design_temp)
```

### 10. Then apply the empirical bayes procedure:
```{r,echo=TRUE}
fit=eBayes(fit,robust=TRUE)
```
We use the robust=TRUE setting to leverage the quality weights such that the analysis is robust to outliers.

One can then get a quick and dirty summary of how many genes are differentially expressed, setting the FDR threshold,where the "fdr" and "BH" methods are synonymous for Benjamini Hochberg adjusted p-values.

11. Get summary table:
```{r,echo=TRUE}
summary(decideTests(fit,adjust.method="fdr",p.value = 0.05))
```
One piece of important info is the factor relative to which logfold change is being calculated, i.e. low will be the numerator for logfold change calculations.

Overall, (1589+1728)/13307 or ~ 24.9% of genes are differentially expressed as a function of temperature treatment, without considering the effect of population.

12. Explore the data by extracting the top 10 DE genes (sorted by p-value):
```{r,echo=TRUE}
topTable(fit, adjust="BH",resort.by="P")
```
The full table will be useful for many purposes, such as creating custom MA or volcano plots with color-coding and symbols to meet your needs.

13. Create a table of all genes (significant and not)
```{r,echo=TRUE}
all_genes<-topTable(fit, adjust="BH",coef="templow", p.value=1, number=Inf ,resort.by="P")
```
coeff = the coefficient or contrast you want to extract  
number = the max number of genes to list  
adjust = the P value adjustment method  
resort.by determines what criteria with which to sort the table  


## Extending to more complicated designs
Extending limma to analyze more complex designs, such as when considering two factors, temperature and population, is relatively straightforward. A key part is to specify the design matrix properly. For the 2-factor design, one would do this as follows:

### 14. build design matrix for 2-factor model
```{r,echo=TRUE}
population <- factor(sample_info$population,levels=c("maine","panama"))
temperature <- factor(sample_info$temp, levels=c("high","low"))
design_2factor<- model.matrix(~population+temperature)
design_2factor
```
Then, you would proceed with DE analysis in a similar fashion as with the single factor experiment described above. Notice that we have specified the levels of temperature such that low is second, which results in "templow" being the dummy variable with which to fit the coefficient for temperature. 

### 15. run voom with quality weights on DGE object but with 2-factor design matrix

```{r,echo=TRUE}
vwts_2factor <- voomWithQualityWeights(DGE, design=design_2factor,normalize.method="none", plot=TRUE)
fit_2factor=lmFit(vwts_2factor,design_2factor)
fit_2factor=eBayes(fit_2factor,robust=TRUE)
summary(decideTests(fit_2factor,adjust.method="fdr",p.value = 0.05))
```

There are now (2259+2402)/13307 or ~ 36.4% of genes are differentially expressed as a function of temperature after partitioning variation among temperature and population-level effects. In essence, accounting for population-level variation provided greater power in detecting the effects of temperature, as in the above 1-factor test, only 24.9% of genes were differentially expressed with respect to temperature.

### 16. get full results table:
```{r,echo=TRUE}
all_genes<-topTable(fit_2factor, adjust="BH",coef="temperaturelow", p.value=1, number=Inf ,resort.by="P")
all_genes$geneid<-row.names(all_genes)
```


# III. Final thoughts on limma voom
One of limma's big advantages is that, for complex experiments, one is able to specify arbitrary contrasts to extract and test, leveraging the full spectrum of options for linear modeling. However, doing so **properly** requires a thorough understanding of linear modeling. 


    

