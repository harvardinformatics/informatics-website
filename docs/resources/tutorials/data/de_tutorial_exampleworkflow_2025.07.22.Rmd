---
title: 'FAS Informatics July 2025:Differential Expression Tutorial Example'
output:
  html_document: default
---

# I. Preliminaries
The goal of this workshop is to provide an introduction to differential expression analyses using RNA-seq data. While there are now many published methods for tackling specific steps, as well as full-blown pipelines, we will focus on using the outputs of the nf-core/rnaseq workflow that generates expression estimates from STAR alignments with salmon, to conduct differential expression tests with limma voom.

The expression estimates fed into sleuth and limma voom were created with an annotated genome. The process involved in performing such analyses using a de novo transcriptome assembly is quite similar, with the caveat that there can be biases in expression estimates derived from these methods, and the pipeline for filtering, annotating, and clustering such assemblies into gene level annotations has a substantial impact on the robustness of expression estimates.  

A broader goal of this workshop is to demonstrate how to analyze complex designs that are not the standard one treatment, two condition analyses that are prevalent in the literature. 

## Sample data
Our sample data comprises 12 paired-end RNA-seq libraries for whole body samples of *Drosophila melanogaster* from two geographic regions (Panama and Maine), with two temperature treatments ("low" ane "high") for each region, featuring three biological replicates for each region x treatment combination. Previously, these data were used to look for parallel gene expression patterns between high and low latitude populations (Zhao et al, 2015, *PLoS Genetics*)

## Loading required R libraries
First, install the R libraries that will be used for today's analyses:
```{r,quietly = TRUE}
install.packages("tidyverse","ggrepel")

if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("limma","edgeR")
```

Then load them:

```{r, echo=TRUE}
library(limma)
library(edgeR)
library(tidyverse)
```

# II. Analysis with limma voom

### 1. load gene-level abundance table
he first two columns of `salmon.merged.gene_counts.tsv` are "gene_id", the original gene id in the annotation, and "gene_name", the gene symbol. To manipulate the data into a matrix format that limma expects, we also need to remove the id and name information from the data table, and set  gene names as row names. 

```{r}
expression_data <-read.table("salmon.merged.gene_counts.tsv",header=TRUE,row.names="gene_name")
expression_data$gene_id <- NULL
```

### 2. Load sample info
We not only load the sample info, but also create a new variable, *pop_temp*, that is the concatenation of the two categorical variables. We don't use this variable for downstream analyses--although we could if we wanted to specify particular linear contrasts--but for our purposes, we will use this variable when filtering out lowly expressed genes, as the filtering is also meant to insure that there are sufficient within-group counts.

```{r}
sample_info <- read.table("dme_elev_samples.tsv",header = TRUE, stringsAsFactors=FALSE)
sample_info$pop_temp<-paste(sample_info$population,sample_info$temp,sep="_")
```

### 3. Create Digital Gene Expression (DGE) object

```{r}
DGE=DGEList(expression_data,samples=sample_info$sample,group=sample_info$pop_temp)
```

### 4. filtering lowly expressed genes
A number of transcripts/genes will be not expressed at all in any sample, or may only be expressed in a small number of samples. In the latter case, testing for differential expression is noisy and under-powered. Specifically we use the `filterByExpr` function in `edgeR` to identify genes have a minimum count for a minimum number of samples within each group defined in the `DGE` object.  We then use the boolean output of that function (where TRUE means the minimum count criterion is satisfied) to filter the DGE.

```{r}
keep.exprs <- filterByExpr(DGE)
DGE <- DGE[keep.exprs,, keep.lib.sizes=FALSE]
```

### 5. TMM normalization
The next step is conducting normalization of the counts across samples so that library size differences and the effects of genes that are highly expressed and sample specific are accounted for. Regarding the latter, we want to avoid having a few genes take up expression sequencing "real estate" given the overall number of reads generated by a sample, such that it reduces the reads in other transcripts in a way that would lead to false positive DE. To do this, we use the trimmed mean of M-values (TMM)  of Robinson and Oshlack (2010) available in edgeR. Note, one can use other normalization schemes, and I have seen some evidence that conditional quantile normalizartion (CQN) mignt be worth considering as an alternative.

```{r}
DGE<-calcNormFactors(DGE,method =c("TMM"))
```

### 6. Quick and dirty MDS visualization 
We do this to make sure there are no outliers with respect to a particular experimental variable:
```{r,echo=TRUE}
tempvals<-sample_info$temp
popvals<-sample_info$population
mds<-plotMDS(DGE,top=500,plot=FALSE,gene.selection="common")
mds_dataframe <-cbind(sample_info$sample,sample_info$pop_temp,mds$x,mds$y)
colnames(mds_dataframe) <-c("sample","poptemp","pc1","pc2")
mds_dataframe <- as_tibble(mds_dataframe) %>% mutate(across(c(pc1, pc2), as.numeric))

mds_plot <- mds_dataframe %>% ggplot(aes(x=pc1,y=pc2,color=poptemp)) +
            geom_point(size=3) +
            xlab("Principal coordinate 1") +
            ylab("Principal coordinate 2") +
            geom_text_repel(aes(label = sample), size=3)
print(mds_plot)

```

As expected, there is clear separation between temeprature regimes and geographic locations, but no outliers indicating bad samples or potential label swaps.


## The vanilla one factor, two treatment DE analysis
A fundamental step of DE analysis is to construct a design matrix that will be used to fit the linear model. In our simple vanilla 2-condition, example we can simply use the temp variable in the s2c table to create a matrix. which represents binary 0/1 encodings of the temp conditions.

### 7. Create design matrix:
```{r,echo=TRUE}
design_temp<-model.matrix(~temp, data=sample_info)
design_temp
```

### 8a. Running limma
After creating the design matrix object, the standard approach is to next run limma voom on the DGE object, e.g.:
```{r,echo=TRUE,eval=FALSE}
v <- voom(DGE, design=design_temp, plot=TRUE)
```
**However** ... while this works fine under an ideal scenario, it becomes a problem if there is variation in sample quality, or more generally, there is some indication that a subset of samples appear as outliers via MDS, PCA, etc. Particularly for RNA-seq experiments where researchers may only have a few repicates per sample, discarding outlier samples is not feasible because it may lead to few if any biological replicates for some subset of treatments. 

A better solution to this problem is to apply weights to samples such that outlier samples are down-weighted during differential expression calculations. Limma voom does this by calculating "empirical quality weights" for each sample. Note that we don't specify a normalization method becaues the data have already been normalized with TMM.

### 8b. Run limma voom with sample quality weights:
```{r,echo=TRUE}
vwts <- voomWithQualityWeights(DGE, design=design_temp,normalize.method="none", plot=TRUE)
```

**Note:** we have already applied TMM normalization, thus can set the normalization argument to none. This above command will also generate a plot with two panels showing the mean-variance relationship fit on the left, and a barplot of weights assigned to individual samples.

### 9. Then, run the linear model fitting procedure 1st step:
```{r,echo=TRUE}
fit<-lmFit(vwts,design_temp)
```

### 10. Then apply the empirical bayes procedure:
```{r,echo=TRUE}
fit<-eBayes(fit,robust=TRUE)
```
We use the robust=TRUE setting to leverage the quality weights such that the analysis is robust to outliers.

One can then get a quick and dirty summary of how many genes are differentially expressed, setting the FDR threshold,where the "fdr" and "BH" methods are synonymous for Benjamini Hochberg adjusted p-values.

11. Get summary table and make volcano plot:
```{r,echo=TRUE}
summary(decideTests(fit,adjust.method="fdr",p.value = 0.05))
```
One piece of important info is the factor relative to which logfold change is being calculated, i.e. low will be the numerator for logfold change calculations.

Overall, (1589+1728)/13307 or ~ 24.9% of genes are differentially expressed as a function of temperature treatment, without considering the effect of population.

We can also make a quick and dirty volcano plot, where the x-axis is log-fold change, and the y-axis is -log10(Pvalue) using limma's `volcanoplot` function:

```{r}
volcanoplot(fit,coeff=1)
```

Remember, the coefficient indexed by 0 is the intercept, which we are less interested in. Thus, 1 would refer to `templow`. The volcano plot suggests there are far more genes that are up-regulated in the low temperature condition (i.e. with log-fold change > 0) than there are genes up-regulated in the high temperature condition.

12. Explore the data by extracting the top 10 DE genes (sorted by p-value):
```{r,echo=TRUE}
topTable(fit, adjust="BH",resort.by="P")
```
The full table will be useful for many purposes, such as creating custom MA or volcano plots with color-coding and symbols to meet your needs.

13. Create a table of all genes (significant and not)
```{r,echo=TRUE}
all_genes<-topTable(fit, adjust="BH",coef="templow", p.value=1, number=Inf ,resort.by="P")
```
coeff = the coefficient or contrast you want to extract  
number = the max number of genes to list  
adjust = the P value adjustment method  
resort.by determines what criteria with which to sort the table  


## Extending to more complicated designs
Extending limma to analyze more complex designs, such as when considering two factors, temperature and population, is relatively straightforward. A key part is to specify the design matrix properly. For the 2-factor design, one would do this as follows:

### 14. build design matrix for 2-factor model
```{r,echo=TRUE}
population <- factor(sample_info$population,levels=c("maine","panama"))
temperature <- factor(sample_info$temp, levels=c("high","low"))
design_2factor<- model.matrix(~population+temperature)
design_2factor
```
Then, you would proceed with DE analysis in a similar fashion as with the single factor experiment described above. Notice that we have specified the levels of temperature such that low is second, which results in "templow" being the dummy variable with which to fit the coefficient for temperature. 

### 15. run voom with quality weights on DGE object but with 2-factor design matrix

```{r,echo=TRUE}
vwts_2factor <- voomWithQualityWeights(DGE, design=design_2factor,normalize.method="none", plot=TRUE)
fit_2factor<-lmFit(vwts_2factor,design_2factor)
fit_2factor<-eBayes(fit_2factor,robust=TRUE)
summary(decideTests(fit_2factor,adjust.method="fdr",p.value = 0.05))
```

There are now (2259+2402)/13307 or ~ 36.4% of genes are differentially expressed as a function of temperature after partitioning variation among temperature and population-level effects. In essence, accounting for population-level variation provided greater power in detecting the effects of temperature, as in the above 1-factor test, only 24.9% of genes were differentially expressed with respect to temperature.

### 16. get results table for all genes
As before, we can get the entire table (including those that do not show significant DE). **NOTE:** when we fit models with limma with a multi-factor design there are now two possible coefficients to select. Because we are interested in the effects of temperature, we specify *temperaturelow*. If we wanted to look at genes with differential regulation with respect to population, we would have to specify *populationpanama*.

```{r,echo=TRUE}
all_genes<-topTable(fit_2factor, adjust="BH",coef="temperaturelow", p.value=1, number=Inf ,resort.by="P")
all_genes$geneid<-row.names(all_genes)
```

## Specifying particular comparisions: data subsetting
In a simple experiment where you have two groups of samples, with each assigned to one of two different conditions, following a workflow akin to the "vanilla one factor" one described above is a perfectly reasonable. For example, if there was no second "population" factor, such as if flies had only been collected from Panama and subjected to either high or low temperature treatments. However, not all experiments are that straightforward. For example, you may one factor, and several levels for that factor, and you might only be interested in specific comparisons. Imagine a case where there are three temperature levels: low, medium and high, and you are only interested in changes relative to "low". In other words, you might only want to test for DE between a) medium and low and b) high and low. Or, in a two factor experiment such as in our example data, you might only be interested in testing for changes between high and low temperature within each population. One way to perform these tests is to:

1. subset the DGE to only include samples from the conditions of interest
2. create a design matrix from this subsetted data, and
3. run the DE testing with limma per the "vanilla experiment

We will demonstrate how this is done for carrying out a DE test for high versus low temperature only within the Panama population

### subset the data
#### subset the DGE
```{r}
panama_samples<-sample_info$sample[sample_info$population=="panama"]
panama_DGE <- DGE[,panama_samples]
```

#### subset the sample info table
We do this by selecting rows with "panama" for the value of the population factor, and include all columns. Because limma and edgeR work with data frames and not tibbles, we use base R code for doing this.
```{r}
panama_sample_info <-sample_info[sample_info$population=="panama",]
panama_sample_info$temp<-factor(panama_sample_info$temp, levels=c("high","low"))
panama_sample_info
```

### create design matrix for subsetted data

```{r,echo=TRUE}
panama_design_temp=model.matrix(~temp, data=panama_sample_info)
panama_design_temp
```

### do DE testing on Panama samples
```{r,echo=TRUE}
vwts_panama <- voomWithQualityWeights(panama_DGE, design=panama_design_temp,normalize.method="none", plot=TRUE)
panama_fit=lmFit(vwts_panama,panama_design_temp)
panama_fit=eBayes(panama_fit,robust=TRUE)
summary(decideTests(panama_fit,adjust.method="fdr",p.value = 0.05))
topTable(panama_fit, adjust="BH",resort.by="P")
```

## Specifying particular comparisions: linear contrasts
Under the hood, `limma` fits linear models to patterns of expression across conditions, such that, when it performs differential expression tests, it is testing the null hypothesis that the coefficient for a particular term in the linear model is equal to zero. `limma` leverages the design matrix to build the model from which statistical tests will be performed on the coefficients of that model. In the simple case of the dataset restricted to samples from Panama, our model is $$ Expression\ of\ gene\ A = \beta_0 + temperature \ group* \beta_1 $$

In the above formula, *temperature group* references the group coding for the temperature factor in the design matrix. Because "high" is the first level, it is represented in the matrix by zeroes, and "low" by ones. `limma` interprets this coding to assign samples to groups, and constructs a model where the first coefficient represents the mean expression of *gene A*, and the second coefficient represents the difference in expression between low and high temperature conditions, i.e. low-high. One of limma's big advantages is that, for complex experiments, one is able to specify arbitrary contrasts to extract and test, leveraging the full spectrum of options for linear modeling. However, doing so **properly** requires a thorough understanding of linear modeling. If you wish to read more about linear modeling in voom, we recommend the [chapter 9 of thelimma user's guide](https://bioconductor.org/packages/release/bioc/vignettes/limma/inst/doc/usersguide.pdf). Nevertheless, there is a straightforward syntax for specifying particular "contrasts" that reflect different biological hypotheses of interest, and without having to subset the data. We demonstrate this below.

### Building a contrast design matrix
You may recall that in our original `sample_info` object we created a variable named `pop_temp`. This variable concatenation is a key part of specifying contrasts in a straightforward manner. But first, we need to assign factor levels to these combinations:

```{r}
poptemp<-factor(sample_info$pop_temp,levels=c("maine_low","maine_high","panama_low","panama_high"))
```
Then we create our contrast design

```{r}
contrast_design<-model.matrix(~0+poptemp)
colnames(contrast_design) <- levels(poptemp)
contrast_design
```
In this design, each value for `poptemp` gets a column, with ones indicating if the sample is assigned to that value. Once it has been created, we can make a contrast matrix:

```{r}
cont.matrix <- makeContrasts(Mlowhi=maine_low-maine_high,Plowhi=panama_low-panama_high,Diff=(maine_low-maine_high)-(panama_low-panama_high),levels=contrast_design)
cont.matrix
```
such that:
* `Mlowhi` specifies a contrast (and model coefficient) for the difference in expression between low and high temperature expression in Maine
* `Plowhi` specifies a contrast for the difference in expression between low and high temperature in Panama, and
* `Diff` specifies an interaction term for evaluating whether the nature of the difference between low and high temperature depends upon geographic location, i.e. does the difference vary by geography

### Build a voom object for the contrast design
Next, we need to rebuild a voom object specifying the new design:
```{r}
vwts_contrast <- voomWithQualityWeights(DGE, design=contrast_design,normalize.method="none", plot=TRUE)
```

### do DE testing
#### run linear model fitting
```{r} 
fit_2factor_contrast=lmFit(vwts_contrast,contrast_design)
```
#### fit contrasts
```{r}
fit_2factor_contrast<-contrasts.fit(fit_2factor_contrast, cont.matrix)
```

#### run empirical Bayes procedure
```{r}
fit_2factor_contrast=eBayes(fit_2factor_contrast,robust=TRUE)
```

#### get summary table
We can generate a summary table as with the above examples, but also visualize overlap of significant differences between coefficients.
```{r}
contrast_summary<-decideTests(fit_2factor_contrast,adjust.method="fdr",p.value = 0.05)
summary(decideTests(fit_2factor_contrast,adjust.method="fdr",p.value = 0.05))
vennDiagram(contrast_summary)
```

### create merged results table
Because the first, second and third coefficients in the ```cont.matrix``` are for `Mlowhi`, `Plowhi`, and  `Diff`, we can extract the results for each contrast and combine the results into a single table:

```{r}
Mlowhi_results<-topTable(fit_2factor_contrast, adjust="BH",coef=1, p.value=1, number=Inf ,resort.by="P")
colnames(Mlowhi_results)<-paste("Mlowhi",colnames(Mlowhi_results),sep=".")
Mlowhi_results$geneid<-row.names(Mlowhi_results)
Plowhi_results<-topTable(fit_2factor_contrast, adjust="BH",coef=2, p.value=1, number=Inf ,resort.by="P")
colnames(Plowhi_results)<-paste("Plowhi",colnames(Plowhi_results),sep=".")
Plowhi_results$geneid<-row.names(Plowhi_results)
Diff_results<-topTable(fit_2factor_contrast, adjust="BH",coef=3, p.value=1, number=Inf ,resort.by="P")
colnames(Diff_results)<-paste("Diff",colnames(Diff_results),sep=".")
Diff_results$geneid<-row.names(Diff_results)
results_merge<-merge(Mlowhi_results,Plowhi_results,by=c("geneid"))
results_merge<-as_tibble(merge(results_merge,Diff_results,by=c("geneid")))
head(results_merge)
```

Once this merged table is created, one can query it using *tidyverse* table parsing to ask particular questions of interest. For example, which genes are up-regulated in high temperature conditions in a parallel fashion between Panama and Maine? To do this, you would want to identify genes where there is a non-significant interaction term, log-fold change is negative in both regions (remember, the contrast and factor levels mean it's low-high, so negative values mean up-regulation with high temperature), and significant for both regions, assuming an FDR level of 0.05.

```{r}
parallel_high_upreg_genes <-results_merge %>% filter(Diff.adj.P.Val > 0.05) %>%
                  filter(Plowhi.adj.P.Val <=0.05) %>%
                  filter(Mlowhi.adj.P.Val <=0.05) %>%
                  filter(Plowhi.logFC < 0) %>%
                  filter(Mlowhi.logFC < 0)
head(parallel_high_upreg_genes)
```
A total of 378 genes fit the pattern of parallel, significant upregulation with high temperature.

                  
